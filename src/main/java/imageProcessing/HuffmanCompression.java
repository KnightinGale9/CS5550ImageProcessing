package imageProcessing;

import java.io.ByteArrayOutputStream;
import java.util.*;

public class HuffmanCompression {
    HuffmanNode root=null;
    HashMap<Integer,String> huffmanStorage = new HashMap<>();
    HashSet<HuffmanNode> huffmanNodesStroage = new HashSet<>();
    public ArrayList<String> huffmanEncoding(byte[] imageRaster)
    {
        ByteArrayOutputStream encoder = new ByteArrayOutputStream();
        HashMap<Integer,Integer> imageDict = new HashMap<>();
        for(int i=0; i < imageRaster.length; i++)
        {
            if(!imageDict.containsKey(Byte.toUnsignedInt(imageRaster[i])))
            {
                imageDict.put(Byte.toUnsignedInt(imageRaster[i]),1 );
            }
            imageDict.put((Byte.toUnsignedInt(imageRaster[i])),imageDict.get(Byte.toUnsignedInt(imageRaster[i]))+1 );
        }
//        System.out.println(imageDict);
        PriorityQueue<HuffmanNode> minHeap = new PriorityQueue<>(imageDict.size(),new HuffmanMinComparator());
        for (Integer data:imageDict.keySet()) {
            HuffmanNode huff= new HuffmanNode(data,imageDict.get(data));
            minHeap.add(huff);
        }
        while (minHeap.size() > 1) {

            // first min extract.
            HuffmanNode x = minHeap.poll();

            // second min extract.
            HuffmanNode y = minHeap.poll();

            // new node f which is equal
            HuffmanNode f = new HuffmanNode(-1,x.getFrequency()+y.getFrequency());

            // first extracted node as left child.
            f.setLeft(x);

            // second extracted node as the right child.
            f.setRight(y);

            // marking the f node as the root node.
            root = f;

            // add this node to the priority-queue.
            minHeap.add(f);
        }
        System.out.println("debug");
        this.printCode(root,"");
        System.out.println(huffmanStorage.toString());
        return huffmanCode(imageRaster);
        // print the codes by traversing the tree
//        printCode(root, "");
    }
    public ArrayList<String> huffmanCode(byte[] imageRaster)
    {
        ArrayList<String> storage = new ArrayList<>();
        for(int i=0;i<imageRaster.length;i++)
        {
            storage.add(huffmanStorage.get(Byte.toUnsignedInt(imageRaster[i])));
        }
        return storage;
    }
    public double huffmanLength()
    {
        double Lavg=0;
        for (HuffmanNode node:huffmanNodesStroage) {
            String code =huffmanStorage.get(node.getData());
            Lavg+=node.getFrequency() * code.length();
        }
        return Lavg;
    }

    public ArrayList<Integer> decodeHuffman(ArrayList<String> encoded)
    {
        ArrayList<Integer> decoded = new ArrayList<>();
        for(int i=0;i<encoded.size();i++) {
            HuffmanNode tranversal = root;
            String code = encoded.get(i);
            for (int j = 0; j < code.length(); j++) {
                if (code.charAt(j) == '0') {
                    tranversal = tranversal.getLeft();
                } else {
                    tranversal = tranversal.getRight();
                }
            }
            decoded.add(tranversal.getData());
        }
        return decoded;
    }
    public  void printCode(HuffmanNode root, String s)
    {

        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (root.getLeft() == null && root.getRight() == null
                && root.getData()>=0) {

            // c is the character in the node
//            System.out.println(root.data + ":" + s);
            huffmanStorage.put(root.getData(),s);
            huffmanNodesStroage.add(root);
            return;
        }

        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.

        // recursive calls for left and
        // right sub-tree of the generated tree.
        printCode(root.getLeft(), s + "0");
        printCode(root.getRight(), s + "1");
    }
    class HuffmanNode {
        private int data;
        private int frequency;

        private HuffmanNode left=null;
        private HuffmanNode right=null;

        public HuffmanNode(int data,int f)
        {
            this.data=data;
            this.frequency=f;
        }
        public int getData() {
            return data;
        }

        public int getFrequency() {
            return frequency;
        }
        public HuffmanNode getLeft() {
            return left;
        }

        public void setLeft(HuffmanNode left) {
            this.left = left;
        }

        public HuffmanNode getRight() {
            return right;
        }

        public void setRight(HuffmanNode right) {
            this.right = right;
        }

    }

    // comparator class helps to compare the node
    // on the basis of one of its attribute.
    // Here we will be compared
    // on the basis of data values of the nodes.
    class HuffmanMinComparator implements Comparator<HuffmanNode> {
        public int compare(HuffmanNode x, HuffmanNode y)
        {
            return x.getFrequency()-y.getFrequency();
        }
    }

}
